/*
 * Automatically generated by ../tools/mkgetopt.py [v1.0.2]
 * Input file: dd-wipe-opt.in
 *
 * DO NOT EDIT THIS FILE!
 *
 * Make all changes in dd-wipe-opt.in.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include <assert.h>
#include <errno.h>


#include "getopt_long.h"
#include "error.h"

#include "dd-wipe-opt.h"

static const struct option Long_options[] =
{
      {"help",                            no_argument,       0, 300}
    , {"cpu",                             required_argument, 0, 302}
    , {"pause",                           required_argument, 0, 303}
    , {"iosize",                          required_argument, 0, 304}
    , {"wipes",                           required_argument, 0, 305}
    , {"verbose",                         no_argument,       0, 306}

    , {0, 0, 0, 0}
};

static const char Short_options[] = "hc:p:z:w:v";

static unsigned long grok_int(const char * str, const char * option, char * present, int * err, unsigned long limit, int has_limit);
static uint64_t grok_size(const char * str, const char * option, char * present, int * err);
static void show_help(void);



/*
 * Parse command line options.
 * Return:
 *    0 on success
 *    > 0 on error (number of errors encountered)
 */
int
opt_parse(opt_option * opt, int argc, char * const *argv)
{
    int c,
        errs = 0;

    /*
     * Assume that getopt library has been used before this call;
     * and reset explicitly.
     */
    optind = 0;

    opt->help = 0;
    opt->ncpu = 0;
    opt->iopause = 0;
    opt->iosize = 268435456;
    opt->wipes = 1;
    opt->verbose = 0;

    opt->help_present = 0;
    opt->ncpu_present = 0;
    opt->iopause_present = 0;
    opt->iosize_present = 0;
    opt->wipes_present = 0;
    opt->verbose_present = 0;


    opt->argv_inputs = 0;
    opt->argv_count  = 0;

    if (argc == 0)
        return 0;

    if (argc < 0 || !argv || !argv[0])
        return 0;

    while ((c = getopt_long(argc, argv, Short_options, Long_options, 0)) != EOF) {
        switch (c) {
        case 300:  /* help */
        case 'h':  /* help */
            opt->help = 1;
            opt->help_present = 1;
            fflush(stdout);
            fflush(stderr);
            show_help();
            break;

        case 302:  /* cpu */
        case 'c':  /* cpu */
            if (optarg && *optarg)
            {
                opt->ncpu = (int)grok_int(optarg, "cpu",
                                    &opt->ncpu_present, &errs,
                                    INT_MAX, 1);
            }
            break;

        case 303:  /* pause */
        case 'p':  /* pause */
            if (optarg && *optarg)
            {
                opt->iopause = (int)grok_int(optarg, "pause",
                                    &opt->iopause_present, &errs,
                                    INT_MAX, 1);
            }
            break;

        case 304:  /* iosize */
        case 'z':  /* iosize */
            if (optarg && *optarg)
                opt->iosize = grok_size(optarg, "iosize",
                                    &opt->iosize_present, &errs);
            break;

        case 305:  /* wipes */
        case 'w':  /* wipes */
            if (optarg && *optarg)
            {
                opt->wipes = (int)grok_int(optarg, "wipes",
                                    &opt->wipes_present, &errs,
                                    INT_MAX, 1);
            }
            break;

        case 306:  /* verbose */
        case 'v':  /* verbose */
            opt->verbose = 1;
            opt->verbose_present = 1;
            break;



        default:
            ++errs;
            break;
        }
    }

    opt->argv_inputs = &argv[optind];
    opt->argv_count  = argc - optind;

    /*
     * Reset getopt library for next use.
     */
    optind = 0;

    return errs;
}


/**
 * @memo Grok a integer in any base (auto detect)
 *
 * @param str     String containing an integer (possibly signed)
 * @param option  The corresponding option string (for emitting errors)
 * @param present Output value -- true if there are no errors, false otherwise
 * @param err     Output value -- incremented on errors
 * @param limit   The maximum permissible limit for this integer
 * @param has_limit   Set if the corresponding option had a size limitation
 *                (e.g., a short integer etc.)
 * @return Converted string value.
 */
static unsigned long
grok_int(const char * str, const char * option, char * present, int * err,
            unsigned long limit, int has_limit)
{
    char * xxend = 0;
    long lim_pos = (long) limit,
         lim_neg = -lim_pos - 1;
    int isneg = 0;
    union
    {
        long l;
        unsigned long ul;
    } un;

    if (*str == '-') {
        ++str;
        isneg = 1;
    }

    un.ul = strtoul(str, &xxend, 0);
    if (xxend && *xxend)
        error(0, 0, "Ignoring trailing characters '%s' for option '%s'", xxend, option);

    if (isneg) {
        un.l *= -1;
    }

    if (has_limit) {
        if (isneg && un.l < lim_neg) {
            *err += 1;
            error(0, 0, "Integer value '-%s' underflow for option '%s' (min %ld)",
                    str, option, lim_neg);
        } else if (!isneg && un.ul > (unsigned long)lim_pos) {
            *err += 1;
            error(0, 0, "Integer value '%s' overflow for option '%s' (max %lu)",
                    str, option, lim_pos);
        }
    }
    else
        *present = 1;

    return un.ul;
}

/**
 * @memo Grok a size specification string.
 *
 * @doc Handles suffixes of 'k', 'M', 'G', 'T', 'P'
 *
 * @param str     String containing size like '36k' or '14M'
 * @param option  The corresponding option string (for emitting errors)
 * @param present Output value -- true if there are no errors, false otherwise
 * @param err     Output value -- incremented on errors
 *
 * @return Converted value of the size
 */
static uint64_t
grok_size(const char * str, const char * option, char * present, int * err)
{
    int errs = 0;
    uint64_t   xxbase = 0,
               xxmult = 1,
               xxval  = 0;

    char * xxend = 0;

    /* MS is weird. They deliberately chose NOT to use names that the rest
     * of the world uses. */
#ifdef _MSC_VER
#define strtoull(a,b,c,)  _strtoui64(a,b,c)
#define _ULLCONST(n) n##ui64
#else
#define _ULLCONST(n) n##ULL
#endif

#define UL_MAX__    _ULLCONST(18446744073709551615)
#define _kB         _ULLCONST(1024)
#define _MB         (_kB * 1024)
#define _GB         (_MB * 1024)
#define _TB         (_GB * 1024)
#define _PB         (_TB * 1024)

    *present = 1;
    xxbase = strtoull(str, &xxend, 0);

    if (xxend && *xxend) {
        switch (*xxend) {
            case 'b': case 'B':
                break;
            case 'k': case 'K':
                xxmult = _kB;
                break;
            case 'M':
                xxmult = _MB;
                break;
            case 'G':
                xxmult = _GB;
                break;
            case 'T':
                xxmult = _TB;
                break;
            case 'P':
                xxmult = _PB;
                break;
            default:
                errs++;
                error(0, 0, "Unknown multilplier constant '%c'  for option '%s'",
                        *xxend, option);
                *present = 0;
                break;
        }

        xxval = xxbase * xxmult;
        if ((xxbase == UL_MAX__ && errno == ERANGE) || (xxval < xxbase)) {
            errs++;
            error(0, 0, "Size value overflow for option '%s' (base %lu, multiplier %lu)",
                    option, xxbase, xxmult);
            *present = 0;
        }
    } else
        xxval = xxbase;

    *err += errs;
    return xxval;
}


static void
show_help(void)
{
    const char* desc =
"Multithreaded disk eraser.\n\n"
;
    const char* usage = opt_usage();
    const char* options = 
"\nOptions (defaults within '[ ]'):\n"
"    --help, -h        Print this help and exit [false]\n"
"    --cpu=c, -c c     Run on 'N' CPUs [0]\n"
"    --pause=p, -p p   Pause for 'P' milliseconds after every I/O [0]\n"
"    --iosize=z, -z z  Do I/O in 'Z' sized chunks [256M]\n"
"    --wipes=w, -w w   Wipe each block 'W' times [1]\n"
"    --verbose, -v     Show verbose progress messages [false]\n"
;

    fflush(stdout);
    fflush(stderr);
    printf("%s: %s", program_name, desc);
    fputs(usage, stdout);
    fputs(options, stdout);
    fflush(stdout);
    fflush(stderr);
    exit(0);
}
